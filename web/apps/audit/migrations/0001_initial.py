# -*- coding: utf-8 -*-
# Generated by Django 1.9.5 on 2016-05-23 05:38
from __future__ import unicode_literals

import django.contrib.postgres.fields.hstore
from django.db import migrations, models


def add_extension_hstore():
    return """CREATE EXTENSION IF NOT EXISTS hstore;"""


def if_modified_func_SQL():
    return """CREATE OR REPLACE FUNCTION if_modified_func() RETURNS TRIGGER AS
$body$
DECLARE
    audit_row      logged_actions;
    include_values BOOLEAN;
    log_diffs      BOOLEAN;
    h_old          hstore;
    h_new          hstore;
    excluded_cols  text[] = ARRAY []::text[];
    username       TEXT;
    tmp_exists     BOOLEAN;
BEGIN
    IF TG_WHEN <> 'AFTER' THEN
        RAISE EXCEPTION 'if_modified_func() may only run as an AFTER trigger';
    END IF;

    SELECT to_regclass('user_tmp') IS NOT NULL INTO tmp_exists;
    IF tmp_exists THEN
        SELECT "user_tmp"."username" INTO username FROM "user_tmp" LIMIT 1;
    END IF;

    audit_row = ROW (
        NEXTVAL('audit_next_key'),
        TG_TABLE_SCHEMA::text, -- schema_name
        TG_TABLE_NAME::text, -- table_name
        coalesce(username, session_user::text), -- username from TMP table or from session (session_user::text)
        CURRENT_TIMESTAMP, -- action_tstamp_tx
        statement_timestamp(), -- action_tstamp_stm
        clock_timestamp(), -- action_tstamp_clk
        txid_current(), -- transaction ID
            (SELECT setting FROM pg_settings WHERE name = 'application_name'),
        inet_client_addr(), -- client_addr
        inet_client_port(), -- client_port
        current_query(), -- top-level query or queries (if multistatement) from client
        SUBSTRING(TG_OP, 1, 1), -- action
        NULL,
        NULL, -- row_data, changed_fields
        0 -- statement_only
        );

    IF NOT TG_ARGV[0]::BOOLEAN IS DISTINCT FROM 'f'::BOOLEAN THEN
        audit_row.client_query = NULL;
    END IF;

    IF TG_ARGV[1] IS NOT NULL THEN
        excluded_cols = TG_ARGV[1]::text[];
    END IF;

    IF (TG_OP = 'UPDATE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*);
        audit_row.changed_fields = (hstore(NEW.*) - audit_row.row_data) - excluded_cols;
        IF audit_row.changed_fields = hstore('') THEN
            -- All changed fields are ignored. Skip this update.
            RETURN NULL;
        END IF;
    ELSIF (TG_OP = 'DELETE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*) - excluded_cols;
    ELSIF (TG_OP = 'INSERT' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(NEW.*) - excluded_cols;
    ELSIF (TG_LEVEL = 'STATEMENT' AND TG_OP IN ('INSERT', 'UPDATE', 'DELETE', 'TRUNCATE')) THEN
        audit_row.statement_only = 't';
    ELSE
        RAISE EXCEPTION '[audit.if_modified_func] - Trigger func added as trigger for unhandled case: %, %',TG_OP, TG_LEVEL;
        RETURN NULL;
    END IF;
    INSERT INTO logged_actions
    VALUES (audit_row.*
           );
    RETURN NULL;
END;
$body$
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = pg_catalog, public"""


def audit_table_func_SQL():
    return """CREATE OR REPLACE FUNCTION audit_table(target_table regclass, audit_rows BOOLEAN, audit_query_text BOOLEAN,
                                       ignored_cols text[]) RETURNS void AS
$body$
DECLARE
    stm_targets        text = 'INSERT OR UPDATE OR DELETE OR TRUNCATE';
    _q_txt             text;
    _ignored_cols_snip text = '';
BEGIN
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_row ON ' || quote_ident(target_table::text);
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_stm ON ' || quote_ident(target_table::text);

    IF audit_rows THEN
        IF array_length(ignored_cols, 1) > 0 THEN
            _ignored_cols_snip = ', ' || quote_literal(ignored_cols);
        END IF;
        _q_txt = 'CREATE TRIGGER audit_trigger_row AFTER INSERT OR UPDATE OR DELETE ON ' ||
                 quote_ident(target_table::text) ||
                 ' FOR EACH ROW EXECUTE PROCEDURE if_modified_func(' ||
                 quote_literal(audit_query_text) || _ignored_cols_snip || ');';
        RAISE NOTICE '%',_q_txt;
        EXECUTE _q_txt;
        stm_targets = 'TRUNCATE';
    ELSE
    END IF;

    _q_txt = 'CREATE TRIGGER audit_trigger_stm AFTER ' || stm_targets || ' ON ' ||
             quote_ident(target_table::text) ||
             ' FOR EACH STATEMENT EXECUTE PROCEDURE if_modified_func(' ||
             quote_literal(audit_query_text) || ');';
    RAISE NOTICE '%',_q_txt;
    EXECUTE _q_txt;

END;
$body$
    LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION audit_table(target_table regclass, audit_rows BOOLEAN, audit_query_text BOOLEAN) RETURNS void AS
$body$
SELECT audit_table($1, $2, $3, ARRAY []::text[]);
$body$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION audit_table(target_table regclass) RETURNS void AS
$$
SELECT audit_table($1, BOOLEAN 't', BOOLEAN 't');
$$ LANGUAGE 'sql';
           """


def create_sequence_SQL():
    return """
        CREATE SEQUENCE audit_next_key START 1
        """


class Migration(migrations.Migration):
    initial = True

    dependencies = [
    ]

    operations = [
        migrations.RunSQL(add_extension_hstore()),
        migrations.CreateModel(
            name='LoggedActions',
            fields=[
                ('event_id', models.IntegerField(primary_key=True, serialize=False)),
                ('schema_name', models.CharField(max_length=64, verbose_name='Schema name')),
                ('table_name', models.CharField(max_length=64, verbose_name='Table name')),
                ('session_user_name', models.CharField(max_length=64, verbose_name='Username')),
                ('action_tstamp_tx', models.DateTimeField(verbose_name='Transaction start timestamp')),
                ('action_tstamp_stm', models.DateTimeField(verbose_name='Statement start timestamp')),
                ('action_tstamp_clk', models.DateTimeField(verbose_name='Wall clock time')),
                ('transaction_id', models.BigIntegerField(verbose_name='Transaction ID')),
                ('application_name', models.CharField(max_length=64, verbose_name='Application name')),
                ('client_addr', models.CharField(max_length=64, verbose_name='Client address')),
                ('client_port', models.IntegerField(verbose_name='Client address')),
                ('client_query', models.TextField(verbose_name='Client query')),
                ('action', models.CharField(max_length=1, verbose_name='Action')),
                ('row_data', django.contrib.postgres.fields.hstore.HStoreField(verbose_name='Row data')),
                ('changed_fields', django.contrib.postgres.fields.hstore.HStoreField(verbose_name='Changed fields')),
                ('statement_only', models.BooleanField(verbose_name='Statement only')),
            ],
            options={
                'ordering': [],
                'db_table': 'logged_actions',
                'verbose_name': 'Audit',
                'verbose_name_plural': 'Audit',
            },
        ),
        migrations.RunSQL(create_sequence_SQL()),
        migrations.RunSQL(if_modified_func_SQL()),
        migrations.RunSQL(audit_table_func_SQL())
    ]
